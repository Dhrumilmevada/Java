
-->For writing any java program where it is a simple or complex useful classes and interfaces are grouped in seperate package which is java.lang package.
   But we cannot write one line of code without using lang package.So that lang package is imported implicitly in java language.

									
										java.lang.Object
										----------------
-->Object class is root class of all class in java language because it has a method that can be useful to any class.
-->Object is concider as rrot of all classes.
-->If our does not extend any other class then only our class direct child class of Object class.
-->if our extend any other class then our class is indirect child class of Object class so it is called as multi-level inheritance.
-->Java would not provide multiple inheritence in case of classes.
-->In Object class there is total 11 methods.                       
	1)protected Object clone() throws CloneNotSupportedException
	2)public boolean equals(Object object)
	3)public void finalize() throws Throwable
	4)public int hashCode()
	5)public final class getClass() 
	6)public final void notify()
	7)public final void notifyAll()
	8)public final void wait()
	9)public final void wait() throws InterruptedException                                                
	10)public final void wait(long milliseconds) throws InterruptedException
	11)public final void wait(long milliseconds, int nanoseconds) throws InterruptedException
-->There is a one extra method called as registerNatives() in Object class.


										java.lang.Object.toString()
										---------------------------
-->It is used to get string representation of object.
-->System.out.println(new Object()) = System.out.println(new Object().toString())
-->Printing object reference means calling tiString() method of that object reference.
-->If our class does not immplement toString() then it will be called fron parent Object class.
-->public String toString()
   {
   	return getClass().getName()+"@"+Integer.toHexString(hashCode());
   }
-->We can override string method as per requirment.
-->In String class, Wrapper classes , Collection classes overrides toString() method.
-->It is recommended to override toString() method in our class.

										java.lang.Object.hashCode()
										---------------------------
-->In java it is impossible to know address and size of any object.
-->Hashcode is an unique number for each object.
-->Hashcode is generated by JVM.
-->Hashcode would not represent address of object.
-->JVM will use hashcode while saving into hashing related data structure like hashtable ,hashmap.
-->Main advantage of using hashcode will be the search algoritham became easy.
-->For generating hashcode JVM use a address of object.
-->Overridding of hashCode() method say to be propper if it will generate unique number for each object.
-->jaba.lang.Object.toString() internally calles hashCode() method.

										java.lang.Object.equals()
										-------------------------
-->We use this methods to check the equality of two method.
-->If our class does not containn equals() methos then Object.equals() will be excuted.
-->== operator is meant for reference comparision but .equals() is meant for content comparision.
- ->In Object.equals() is going to compare reference between two object. 
-->If two object pointing to same object then only Object.equals() returns true.
-->We can override Object.equlas() method for content comparision.
-->Object.String.equals() is meant for content comparision.
-->In case of heterogenace object compare by Object.equals() method we have to handle CastclassException and NullPointerException manually and return false 
   or use instenceof qulifier and return true  else false .
-->While overriding Object.equals() method, first of all we have to check for whether both references are refering same object or not.
-->StrinBuffer class does not override Object.equals() method. So that StringBuffer.equals() is gonig to compare reference of two object. 
                                      

                                                                                 java.lang.Object.getClass()
										 ---------------------------
-->We can use getCalss() method to get run time class definaton of an object.
-->getClass() method returns class type.
-->using this Class type Object we can get any type of information of class defination like declare methods, declare constructor, class name.
-->Afetr loading every class file , JVM will crete an object of that type jva.lang.class in heap area.Programmer can use this class object to get class level informaion.


										java.lang.Object.finalize()
										---------------------------

-->finalize() method is going to clean up the object which have not any reference.
--> fianlize is called by garbage collector just before destryong object.


										java.lang.wait()/notify()/notifyAll
										-----------------------------------

-->We can use this method for inter thread communication
-->That thread we expecting updation,it is responsible to call wait() method.then that thread will enter into waiting state.
-->That thread which is responsible for updation afetr performing updation that thread can call notify() method, waiting will get that notification with those updates.
 

										Relation b/w == operator and Object.equals() method
										---------------------------------------------------
-->== opperator returns true if both are refering same object.
-->If you are not override Object.equals() method then == operator and Object.lang() gives same output.
--> r1 == r2 is true then r1.equals(r2) is always true if you are not override Object.equals().
--> r1==r2 is fakse then we can not say anything about result of r1.equals(r2). 
-->r1.equals(r2) is true then we can not anything about r1 == r2.
-->r1.equals(r2) is false then r1==r2 is always false.
-->While using == operator both operand shold be of same type.
-->If there is a both type of object used for .Object.equals() methos then it will alway return false. 
--> r==null or r.equals(null) alway returns false.


										Object.equals() and object.hashCode()
										-------------------------------------
-->Hashing related data structures follow following fundametal rule:
	1)two equivalent object shoud be laced in same Bucket but all objects present in bucket need not to be equal.
 -->If two objct are equal by Object.equals() method then thier hascode must be equal.thta is two equivalent object should have  hashcode.
-->If r1.equals(r2) is true then r1.hashCode() same as r2.hashCode().So that while overridind Object.equals() we can override Object.hashCode() in correspond to change made in Object.equals() method.
-->While overriding Object.equals() it is recommended to override Object.hashCode().
-->if two onjects are not equal by Object.equals() then there is no restriction on hashcode may be equal or may not.
-->If hshcode of two object are equals then be can not conclude anything about Object.equals().
-->If hahscode of two object are not equals then that two object are not equals by Object.equals().
-->To statisfy contract between equals() and hashCode(), we have to override both to proper execution.Example :- java.lang.String.equals() and java.lang.String.hashCode() 
-->In all wrapper class ,Strinng class and collection class Object.equals() method is overrideen for content comparision then it is highly recommended to override Object.hashcode() method. 


 										java.lang.Object.clone()
										------------------------
-->Cloning is process of creating excatly duplicate object.
-->To preserve an orisional state of object we use cloning.
-->Object.clone() is protected method because it will only used by its direct subclass.
-->If class implements java.lang.Clonable interface then we can perform cloning on its object.
-->lang.Clonable interface is marker interface beacause it does not contain any method. 
-->If you trying to preform cloning on non-clonable exception then is show CloneNotSupporedException.
-->Shalllow Cloning
	->Process of bitwise copy of an object is called is called shallow cloning
	->if mainn object containt primitive variable than excatly duplicate copy will be created in the cloned object.
	->If the main object contain any reference variable than corresponding object would not crearted but just duplicate dupliate reference is created and point it to original object.
	->Object.clone() is meant for shallow cloning.
-->Deep cloning
	->Process of creating excatly dupllicate independent copy of main object and including conatain object is called as deep cloning
	->If main object is contain any primtive varible tham its duplicate copy will be created
	->If main object contain any reference object than corresponding object will be created in duplicated object.
	->To implement deep cloning we have to override Object.clone(). 
-->If object contain only primitive variables than go for shallow cloning.
-->if object contain reference variable than go for deep cloning.
	

 	          
                                                                                            












 